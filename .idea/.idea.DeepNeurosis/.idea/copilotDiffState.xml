<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/CharacterController/FirstPersonController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/CharacterController/FirstPersonController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;    &#10;    &#10;namespace PlayerScripts &#10;{&#10;    [RequireComponent(typeof(CharacterController))]&#10;&#10;    public class FirstPersonController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Player Settings&quot;)] public float walkSpeed = 5f;&#10;        public float runSpeed = 10f;&#10;        public float jumpHeight = 1.5f; // Hauteur du saut en mode marche&#10;        public float runJumpHeight = 1f; // Hauteur du saut en mode course&#10;        public float gravity = -20f; // Gravité modérée&#10;        public float fallMultiplier = 2f; // Accélération pendant la descente&#10;&#10;        [Header(&quot;Camera Settings&quot;)] public Transform cameraTransform;&#10;        public float mouseSensitivity = 1f;&#10;        [Range(0.01f, 2f)] public float sensitivityMultiplier = 0.05f; // multiplicateur global&#10;        public float maxLookAngle = 90f;&#10;&#10;        public CharacterController characterController;&#10;        private InputActions inputActions;&#10;        private Vector3 velocity;&#10;        private float cameraPitch = 0f;&#10;        public bool isHidden = false;&#10;&#10;        [Header(&quot;Footstep Manager&quot;)] public FootstepManager footstepManager;&#10;&#10;        // Gestion du curseur&#10;        private bool isCursorLocked = true;&#10;&#10;        void Awake()&#10;        {&#10;            characterController = GetComponent&lt;CharacterController&gt;();&#10;            inputActions = new InputActions();&#10;        }&#10;&#10;        void Start()&#10;        {&#10;            LockCursor(); // Verrouiller le curseur dès le début&#10;        }&#10;&#10;        void OnEnable()&#10;        {&#10;            inputActions.Enable();&#10;        }&#10;&#10;        void OnDisable()&#10;        {&#10;            inputActions.Disable();&#10;        }&#10;&#10;        void Update()&#10;        {&#10;            HandleCursorLock(); // Gérer le verrouillage du curseur&#10;&#10;            if (isCursorLocked)&#10;            {&#10;                HandleMovement();&#10;                HandleCameraRotation();&#10;                ApplyGravityAndJump();&#10;            }&#10;        }&#10;&#10;        private void HandleMovement()&#10;        {&#10;            Vector2 moveInput = inputActions.Character.Move.ReadValue&lt;Vector2&gt;();&#10;            bool isRunning = inputActions.Character.Run.IsPressed();&#10;            float currentSpeed = isRunning ? runSpeed : walkSpeed;&#10;&#10;            Vector3 forward = new Vector3(cameraTransform.forward.x, 0, cameraTransform.forward.z).normalized;&#10;            Vector3 right = new Vector3(cameraTransform.right.x, 0, cameraTransform.right.z).normalized;&#10;            Vector3 moveDirection = forward * moveInput.y + right * moveInput.x;&#10;&#10;            moveDirection.y = velocity.y;&#10;            characterController.Move(moveDirection * currentSpeed * Time.deltaTime);&#10;&#10;            // Appeler le gestionnaire de sons si le joueur bouge et est au sol&#10;            if (characterController.velocity.magnitude &gt; 0.1f &amp;&amp; characterController.isGrounded)&#10;            {&#10;                footstepManager.PlayFootstep(isRunning);&#10;            }&#10;        }&#10;&#10;        private void HandleCameraRotation()&#10;        {&#10;            Vector2 lookInput = inputActions.Character.Look.ReadValue&lt;Vector2&gt;();&#10;            float sens = mouseSensitivity * sensitivityMultiplier;&#10;            transform.Rotate(Vector3.up * lookInput.x * sens);&#10;&#10;            cameraPitch -= lookInput.y * sens;&#10;            cameraPitch = Mathf.Clamp(cameraPitch, -maxLookAngle, maxLookAngle);&#10;            cameraTransform.localRotation = Quaternion.Euler(cameraPitch, 0, 0);&#10;        }&#10;        &#10;        public void SetCameraLock(bool locked)&#10;        {&#10;            isCursorLocked = !locked;&#10;        }&#10;&#10;&#10;        private void ApplyGravityAndJump()&#10;        {&#10;            bool isGrounded = characterController.isGrounded;&#10;&#10;            if (isGrounded)&#10;            {&#10;                velocity.y = -2f; // Légère pression vers le bas pour stabiliser le joueur au sol&#10;&#10;                if (inputActions.Character.Jump.triggered)&#10;                {&#10;                    // Vérifier si le joueur court&#10;                    bool isRunning = inputActions.Character.Run.IsPressed();&#10;&#10;                    // Calculer la hauteur du saut en fonction de l'état&#10;                    if (isRunning)&#10;                    {&#10;                        velocity.y = Mathf.Sqrt(runJumpHeight * -2f * gravity); // Saut plus bas&#10;                    }&#10;                    else&#10;                    {&#10;                        velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity); // Saut normal&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                if (velocity.y &lt; 0)&#10;                {&#10;                    // Appliquer une gravité amplifiée en descente&#10;                    velocity.y += gravity * fallMultiplier * Time.deltaTime;&#10;                }&#10;                else&#10;                {&#10;                    // Appliquer une gravité normale en montée&#10;                    velocity.y += gravity * Time.deltaTime;&#10;                }&#10;            }&#10;&#10;            characterController.Move(Vector3.up * velocity.y * Time.deltaTime);&#10;        }&#10;        &#10;        public void Hide(bool hide)&#10;        {&#10;            isHidden = hide;&#10;            Debug.Log(hide ? &quot;Joueur caché&quot; : &quot;Joueur visible&quot;);&#10;        }&#10;        &#10;        public void ExitHide()&#10;        {&#10;            isHidden = false;&#10;            Debug.Log(&quot;Joueur sorti du casier&quot;);&#10;        }&#10;&#10;&#10;        private void LockCursor()&#10;        {&#10;            Cursor.lockState = CursorLockMode.Locked; // Verrouiller le curseur&#10;            Cursor.visible = false; // Masquer le curseur&#10;            isCursorLocked = true;&#10;        }&#10;&#10;        private void UnlockCursor()&#10;        {&#10;            Cursor.lockState = CursorLockMode.None; // Déverrouiller le curseur&#10;            Cursor.visible = true; // Rendre le curseur visible&#10;            isCursorLocked = false;&#10;        }&#10;&#10;        private void HandleCursorLock()&#10;        {&#10;            if (Keyboard.current.escapeKey.wasPressedThisFrame)&#10;            {&#10;                if (isCursorLocked)&#10;                {&#10;                    UnlockCursor();&#10;                }&#10;                else&#10;                {&#10;                    LockCursor();&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;    &#10;    &#10;namespace PlayerScripts &#10;{&#10;    [RequireComponent(typeof(CharacterController))]&#10;&#10;    public class FirstPersonController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Player Settings&quot;)] public float walkSpeed = 5f;&#10;        public float runSpeed = 10f;&#10;        public float jumpHeight = 1.5f; // Hauteur du saut en mode marche&#10;        public float runJumpHeight = 1f; // Hauteur du saut en mode course&#10;        public float gravity = -20f; // Gravité modérée&#10;        public float fallMultiplier = 2f; // Accélération pendant la descente&#10;&#10;        [Header(&quot;Camera Settings&quot;)] public Transform cameraTransform;&#10;        public float mouseSensitivity = 1f;&#10;        [Range(0.01f, 2f)] public float sensitivityMultiplier = 0.05f; // multiplicateur global&#10;        public float maxLookAngle = 90f;&#10;&#10;        public CharacterController characterController;&#10;        private InputActions inputActions;&#10;        private Vector3 velocity;&#10;        private float cameraPitch = 0f;&#10;        public bool isHidden = false;&#10;&#10;        [Header(&quot;Footstep Manager&quot;)] public FootstepManager footstepManager;&#10;&#10;        // Gestion du curseur&#10;        private bool isCursorLocked = true;&#10;&#10;        void Awake()&#10;        {&#10;            characterController = GetComponent&lt;CharacterController&gt;();&#10;            inputActions = new InputActions();&#10;        }&#10;&#10;        void Start()&#10;        {&#10;            LockCursor(); // Verrouiller le curseur dès le début&#10;        }&#10;&#10;        void OnEnable()&#10;        {&#10;            inputActions.Enable();&#10;        }&#10;&#10;        void OnDisable()&#10;        {&#10;            inputActions.Disable();&#10;        }&#10;&#10;        void Update()&#10;        {&#10;            HandleCursorLock(); // Gérer le verrouillage du curseur&#10;&#10;            if (isCursorLocked)&#10;            {&#10;                HandleMovement();&#10;                HandleCameraRotation();&#10;                ApplyGravityAndJump();&#10;            }&#10;        }&#10;&#10;        private void HandleMovement()&#10;        {&#10;            Vector2 moveInput = inputActions.Character.Move.ReadValue&lt;Vector2&gt;();&#10;            bool isRunning = inputActions.Character.Run.IsPressed();&#10;            float currentSpeed = isRunning ? runSpeed : walkSpeed;&#10;&#10;            Vector3 forward = new Vector3(cameraTransform.forward.x, 0, cameraTransform.forward.z).normalized;&#10;            Vector3 right = new Vector3(cameraTransform.right.x, 0, cameraTransform.right.z).normalized;&#10;            Vector3 moveDirection = forward * moveInput.y + right * moveInput.x;&#10;&#10;            moveDirection.y = velocity.y;&#10;            characterController.Move(moveDirection * currentSpeed * Time.deltaTime);&#10;&#10;            // Appeler le gestionnaire de sons si le joueur bouge et est au sol&#10;            if (characterController.velocity.magnitude &gt; 0.1f &amp;&amp; characterController.isGrounded)&#10;            {&#10;                footstepManager.PlayFootstep(isRunning);&#10;            }&#10;        }&#10;&#10;        private void HandleCameraRotation()&#10;        {&#10;            Vector2 lookInput = inputActions.Character.Look.ReadValue&lt;Vector2&gt;();&#10;            float sens = mouseSensitivity * sensitivityMultiplier;&#10;            transform.Rotate(Vector3.up * lookInput.x * sens);&#10;&#10;            cameraPitch -= lookInput.y * sens;&#10;            cameraPitch = Mathf.Clamp(cameraPitch, -maxLookAngle, maxLookAngle);&#10;            cameraTransform.localRotation = Quaternion.Euler(cameraPitch, 0, 0);&#10;        }&#10;        &#10;        public void SetCameraLock(bool locked)&#10;        {&#10;            isCursorLocked = !locked;&#10;        }&#10;&#10;&#10;        private void ApplyGravityAndJump()&#10;        {&#10;            bool isGrounded = characterController.isGrounded;&#10;&#10;            if (isGrounded)&#10;            {&#10;                velocity.y = -2f; // Légère pression vers le bas pour stabiliser le joueur au sol&#10;&#10;                if (inputActions.Character.Jump.triggered)&#10;                {&#10;                    // Vérifier si le joueur court&#10;                    bool isRunning = inputActions.Character.Run.IsPressed();&#10;&#10;                    // Calculer la hauteur du saut en fonction de l'état&#10;                    if (isRunning)&#10;                    {&#10;                        velocity.y = Mathf.Sqrt(runJumpHeight * -2f * gravity); // Saut plus bas&#10;                    }&#10;                    else&#10;                    {&#10;                        velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity); // Saut normal&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                if (velocity.y &lt; 0)&#10;                {&#10;                    // Appliquer une gravité amplifiée en descente&#10;                    velocity.y += gravity * fallMultiplier * Time.deltaTime;&#10;                }&#10;                else&#10;                {&#10;                    // Appliquer une gravité normale en montée&#10;                    velocity.y += gravity * Time.deltaTime;&#10;                }&#10;            }&#10;&#10;            characterController.Move(Vector3.up * velocity.y * Time.deltaTime);&#10;        }&#10;        &#10;        public void Hide(bool hide)&#10;        {&#10;            isHidden = hide;&#10;            Debug.Log(hide ? &quot;Joueur caché&quot; : &quot;Joueur visible&quot;);&#10;        }&#10;        &#10;        public void ExitHide()&#10;        {&#10;            isHidden = false;&#10;            Debug.Log(&quot;Joueur sorti du casier&quot;);&#10;        }&#10;&#10;&#10;        private void LockCursor()&#10;        {&#10;            Cursor.lockState = CursorLockMode.Locked; // Verrouiller le curseur&#10;            Cursor.visible = false; // Masquer le curseur&#10;            isCursorLocked = true;&#10;        }&#10;&#10;        private void UnlockCursor()&#10;        {&#10;            Cursor.lockState = CursorLockMode.None; // Déverrouiller le curseur&#10;            Cursor.visible = true; // Rendre le curseur visible&#10;            isCursorLocked = false;&#10;        }&#10;&#10;        private void HandleCursorLock()&#10;        {&#10;            if (Keyboard.current.escapeKey.wasPressedThisFrame)&#10;            {&#10;                if (isCursorLocked)&#10;                {&#10;                    UnlockCursor();&#10;                }&#10;                else&#10;                {&#10;                    LockCursor();&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>